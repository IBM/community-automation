---

### schader@us.ibm.com 
### this script is not idempotent.  Re-runs will fail
#
#- name: copy fdisk.delete
#  template:
#   src: fdisk.delete.j2
#   dest: fdisk.delete

#- name: delete any /dev/vdb partitions
#  command: 'fdisk /dev/vdb < fdisk.delete'
#  register: fdisk_delete

#- name: fdisk delete stdout_lines
#  debug: 
#    msg: "{{ fdisk_delete.stdout_lines }}"
#
### umount for re-run testing
- name: umount /dev/vdb1
  mount: 
   path: /mnt
   src: /dev/vdb1
   state: unmounted
  ignore_errors: true

- name: copy fdisk.create
  template:
   src: fdisk.create.j2
   dest: fdisk.create

- name: create the /dev/vdb partition
  shell: 'fdisk /dev/vdb < fdisk.create'
  register: fdisk_create
  
- name: fdisk create stdout_lines
  debug: 
    msg: "{{ fdisk_create.stdout_lines }}"

- name: mkfs.xfs -f /dev/vdb1
  command: 'mkfs.xfs -f /dev/vdb1'
  register: mkfsOutput
  
- name: mkfs create stdout_lines
  debug: 
    msg: "{{ mkfsOutput.stdout_lines }}"

- name: /mnt directory
  file:
    path: /mnt
    state: directory

- name: mount /dev/vdb1
  mount: 
   path: /mnt
   src: /dev/vdb1
   state: mounted
   fstype: xfs
  register: mountOutput
  
- name: mount output
  debug: 
    msg: "{{ mountOutput }}"

- name: prereq directories
  file:
    path: '{{ item }}'
    state: directory
    recurse: yes
  with_items:
  - '/mnt/data'
  - '/mnt/traces'
  - '/mnt/metrics'

- name: get the blkid /dev/vdb1
  command: 'blkid -s UUID -o value /dev/vdb1'
  register: blkidOutput
  
- name: blkidOutput stdout_lines
  debug: 
    msg: "{{ blkidOutput.stdout }}"

- name: remove ( only needed for re-runs on existing host ) /mnt in /etc/fstab
  lineinfile:
    path: '/etc/fstab'
    regexp: '^/mnt'
    state: absent
    backup: yes

- name: add new /mnt in /etc/fstab
  lineinfile:
    path: '/etc/fstab'
    regexp: '^/mnt'
    line: 'UUID="{{ blkidOutput.stdout }}" /mnt xfs defaults 1 1'
    backup: yes

- name: copy settings.hcl
  template:
   src: settings.hcl.j2
   dest: /root/settings.hcl

- name: Add Instana key
  apt_key:
   url: https://self-hosted.instana.io/signing_key.gpg
   state: present

- name: Add Instana repository
  apt_repository:
   repo: deb [arch=amd64] https://self-hosted.instana.io/apt generic main
   state: present

- name: Run the equivalent of "apt-get update" as a separate step
  apt:
    update_cache: yes

- name: install pre-req packages
  become: yes
  apt:
   name: "{{ packages }}"
   state: present
  vars:
   packages:
   - 'instana-console'

- name: instana init -f settings.hcl -y
  shell: 'instana init -f settings.hcl -y'
  register: instanaOutput
  
- name: instana init output
  debug: 
    msg: "{{ instanaOutput.stdout_lines }}"

- name: instana admin credentials
  shell: 'cat instanaCreds 2>/dev/null || (instana configure admin >instanaCreds; cat instanaCreds)'
  register: instanaAdmin

- name: instana version
  shell: 'instana version'
  register: instanaVersion
  
- name: instana version output
  debug: 
    msg: "{{ instanaVersion.stdout_lines }}"

- name: instana license download
  shell: 'instana license download'
  register: licenseOutput
  
- name: instana license output
  debug: 
    msg: "{{ licenseOutput.stdout_lines }}"

- name: instana license import
  shell: 'instana license import'
  register: licenseOutput
  
- name: instana license import output
  debug: 
    msg: "{{ licenseOutput.stdout_lines }}"

- name: instana license verify
  shell: 'instana license verify'
  register: licenseOutput
  
- name: instana license verify output
  debug: 
    msg: "{{ licenseOutput.stdout_lines }}"

- name: Store instana information for subsequent roles
  set_facts: 
    instana_email: "{{ instanaAdmin.stdout |  regex_search('E-Mail: .*') }}"
    instana_password: "{{ instanaAdmin.stdout |  regex_search('Password: .*') }}"
    instana_version: "{{ instanaVersion.stdout }}"